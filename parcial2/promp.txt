
Introducccion

En esta tarea, utilizarás Solidity y ethers.js para implementar una aplicación
descentralizada compleja, o DApp, en Ethereum. Escribirás tanto un contrato
inteligente como el cliente que accede a él, aprendiendo sobre el desarrollo
'full-stack' de una DApp. 


Queremos crear un sistema descentralizado para rastrear débito y crédito: una
versión blockchain de Splitwise. Si no has oído hablar de la aplicación, es una forma
sencilla de realizar un seguimiento de quién debe dinero a quién dentro de un grupo
de personas (tal vez después de dividir el almuerzo, la compra o las facturas). Para
ilustrar la aplicación, considera el siguiente escenario:
Alice, Bob y Carol son amigos a quienes les gusta salir a comer juntos. Bob pagó el
almuerzo la última vez que él y Alice salieron a comer, por lo que Alice le debe a Bob
$10. De manera similar, Carol pagó cuando ella y Bob salieron a comer, por lo que
Bob le debe a Carol $10.
Ahora, imagina que Carol se queda sin efectivo y le pide prestados $10 a Alice.
Observa que en este punto, en lugar de que cada persona devuelva su "préstamo" en algún momento ,
todos podrían estar de acuerdo en que nadie le debe a nadie. En
otras palabras, siempre que hay un ciclo de deuda, podemos simplemente eliminarlo
de nuestra contabilidad, simplificando todo y reduciendo la cantidad de veces que el
efectivo necesita cambiar de manos.
Construiremos una forma descentralizada de rastrear quién le debe qué a quién, de
modo que no sea necesario depender de ningún tercero confiable. Será eficiente: no
costará una cantidad exorbitante de gas almacenar estos datos. No se transferirá
ningún valor "en la cadena de bloques" utilizando esta aplicación; el único ether
involucrado será para gas.
Debido a que está en la cadena de bloques, cuando Carol recoge el cheque por la
comida de ella y Bob, puede pedirle a Bob que envíe un pagaré (lo que él puede
hacer usando nuestra DApp) y puede verificar que efectivamente lo tiene. El
almacenamiento público en cadena servirá como una única fuente de verdad sobre
quién le debe a quién. Más tarde, cuando se resuelva el ciclo ilustrado arriba, Carol
verá que Bob ya no le debe dinero.
Como parte de esto, también crearemos una interfaz de usuario que calcula
información útil para el usuario y permite a los no programadores utilizar la DApp


Necesitamos que el smartContract en solidity  tenga estas funciones:

1. lookup(address debtor, address creditor) public view
returns (uint32 ret): Devuelve el monto que el deudor le debe al
acreedor.


2. add_IOU(address creditor, uint32 amount, ...): Informa al
contrato que msg.sender ahora debe una cantidad mayor de dólares al
acreedor. Es aditivo: si ya debía dinero, esto se sumará. El importe debe ser
positivo. Puede hacer que esta función tome cualquier número de argumentos
adicionales siempre que los dos primeros argumentos sean acreedor y monto.

Las funciones que debe tener el cliente ether.js:

Tenga en cuenta que todas las funciones del cliente que le pedimos que implemente
se proporcionan como funciones asíncronas en el código de inicio. Esto significa que
devuelven un promise de forma predeterminada. Nuestro sistema de calificación
asumirá que se devuelve un promise de cada función del cliente. Para obtener
más información sobre las funciones asíncronas, las promesas y la espera, consulte
la referencia al final de este folleto.
1. getUsers(): Devuelve un promise para una lista de direcciones. La lista
contiene las direcciones de "todos los que alguna vez enviaron o recibieron un
pagaré". Puede que esto le resulte útil como ayuda para otras funciones.
2. getTotalOwed(usuario): Devuelve un promise con el monto total que
debe el usuario determinado.
3. getLastActive(usuario): Devuelve un promise con una marca de
tiempo UNIX (segundos desde el 1 de enero de 1970) de la última actividad
registrada de este usuario (ya sea enviando un pagaré o figurando como
"acreedor" en un pagaré). Devuelve nulo si no se puede encontrar ninguna
actividad.
4. add_IOU(acreedor, monto): Envía un pagaré al contrato, con el acreedor
y el monto especificados. Consulte la sección sobre la resolución de bucles a
continuación.






RESOLUCION DE BUCLES DE DEUDAS
Es útil pensar en los pagarés como un grafo de deudas. Es decir, cada usuario es un
nodo, y cada borde dirigido ponderado de A a B con peso X representa el hecho de
que "A le debe X a B". Escribiremos esto como A X → B. Queremos que nuestra
aplicación 'resuelva' cualquier ciclo en este gráfico restando el mínimo de todos los
pesos en el ciclo de cada paso del ciclo, haciendo así que al menos un paso en el
ciclo tenga un peso de '0'. Por ejemplo, si A 15 → B y B 11 → C, cuando C suma
C 16 → A, los saldos reales se actualizarán para reflejar que A 4 → B, B0 → C y
C 5 → A.



El codigo que hice es el siguiente, espero que mejores dicho codigo 

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.17;
import "hardhat/console.sol";

contract SplitWise {
    mapping(address => mapping(address => uint32)) private debts;
    mapping(address => bool) private visited;

    function add_IOU(address creditor, uint32 amount) public {
        require(amount > 0, "Amount must be positive");
        require(!hasCycle(msg.sender, creditor), "Cycle detected");
        debts[msg.sender][creditor] += amount;
        emit IOUAdded(msg.sender, creditor, amount);
    }

    function hasCycle(address debtor, address creditor) private returns (bool) {
        if (visited[debtor]) {
            return false;
        }
        visited[debtor] = true;

        address[] memory creditors = getCreditors(debtor);
        for (uint256 i = 0; i < creditors.length; i++) {
            address nextCreditor = creditors[i];
            if (nextCreditor == creditor || hasCycle(nextCreditor, creditor)) {
                return true;
            }
        }

        visited[debtor] = false;
        return false;
    }

function getCreditors(address debtor) public view returns (address[] memory) {
    address[] memory creditors = new address.v;
    uint256 numCreditors = 0;
    for (uint256 i = 0; i < getAllPossibleAddresses().length; i++) {
        address possibleCreditor = getAllPossibleAddresses()[i];
        if (debts[debtor][possibleCreditor] > 0) {
            creditors[numCreditors] = possibleCreditor;
            numCreditors++;
        }
    }
    address[] memory result = new address;
    for (uint256 i = 0; i < numCreditors; i++) {
        result[i] = creditors[i];
    }
    return result;
}



    function getAllPossibleAddresses() private pure returns (address[] memory) {
        address[] memory addresses = new address;
        addresses[0] = address(0x123);
        addresses[1] = address(0x456);
        addresses[2] = address(0x789);
        return addresses;
    }

    event IOUAdded(
        address indexed debtor,
        address indexed creditor,
        uint32 amount
    );
}
